#!/usr/bin/env bash
set -euo pipefail

print_usage() {
  cat <<'USAGE'
Usage: boomhauer [options]

Runs a Arlen app from the current app root (or ARLEN_APP_ROOT).
By default, boomhauer watches for source/template/config/public changes,
rebuilds, and restarts the server when files change.

Options:
  --watch        Enable watch mode (default)
  --no-watch     Disable watch mode
  --once         Serve one request and exit (disables watch)
  --prepare-only Compile app/server and exit without starting it
  --help, -h     Show this help

Environment:
  ARLEN_APP_ROOT         App root to run (default: current directory)
  ARLEN_FRAMEWORK_ROOT   Arlen framework root (auto-detected from script path)
USAGE
}

script_path="${BASH_SOURCE[0]}"
if resolved="$(readlink -f "$script_path" 2>/dev/null)"; then
  script_path="$resolved"
fi
script_dir="$(cd "$(dirname "$script_path")" && pwd)"
default_framework_root="$(cd "$script_dir/.." && pwd)"
framework_root="${ARLEN_FRAMEWORK_ROOT:-$default_framework_root}"

if [[ ! -f "$framework_root/GNUmakefile" || ! -d "$framework_root/src/Arlen" ]]; then
  echo "boomhauer: invalid framework root: $framework_root" >&2
  echo "boomhauer: set ARLEN_FRAMEWORK_ROOT to a valid Arlen repository root" >&2
  exit 1
fi

gnustep_sh="/usr/GNUstep/System/Library/Makefiles/GNUstep.sh"
if [[ ! -f "$gnustep_sh" ]]; then
  echo "boomhauer: GNUstep.sh not found at $gnustep_sh" >&2
  exit 1
fi

app_root="${ARLEN_APP_ROOT:-$PWD}"
if [[ ! "$app_root" = /* ]]; then
  app_root="$PWD/$app_root"
fi
app_root="$(cd "$app_root" && pwd)"

watch_mode=1
prepare_only=0
server_args=()
for arg in "$@"; do
  case "$arg" in
    --watch)
      watch_mode=1
      ;;
    --no-watch)
      watch_mode=0
      ;;
    --help|-h)
      print_usage
      exit 0
      ;;
    --prepare-only)
      watch_mode=0
      prepare_only=1
      ;;
    --once)
      watch_mode=0
      server_args+=("$arg")
      ;;
    --print-routes)
      watch_mode=0
      server_args+=("$arg")
      ;;
    *)
      server_args+=("$arg")
      ;;
  esac
done

is_app_root=0
if [[ -f "$app_root/config/app.plist" ]] && ([[ -f "$app_root/src/main.m" ]] || [[ -f "$app_root/app_lite.m" ]]); then
  is_app_root=1
fi

if [[ $is_app_root -eq 0 ]]; then
  cd "$framework_root"
  if [[ $watch_mode -eq 1 ]]; then
    make arlen >/dev/null
    exec "$framework_root/build/arlen" boomhauer --watch "${server_args[@]}"
  fi

  make boomhauer >/dev/null
  if [[ $prepare_only -eq 1 ]]; then
    exit 0
  fi
  export ARLEN_APP_ROOT="$app_root"
  exec "$framework_root/build/boomhauer" "${server_args[@]}"
fi

state_root="$app_root/.boomhauer"
build_root="$state_root/build"
app_binary="$build_root/boomhauer-app"
gen_root="$build_root/gen/templates"
error_output_file="$state_root/last_build_error.log"
error_meta_file="$state_root/last_build_error.meta"
mkdir -p "$gen_root"

watch_fingerprint() {
  local roots=(src templates config public app_lite.m)
  local lines=()
  local rel path

  for rel in "${roots[@]}"; do
    path="$app_root/$rel"
    if [[ -d "$path" ]]; then
      while IFS= read -r file; do
        local rel_file size mtime
        rel_file="${file#"$app_root"/}"
        size="$(stat -c %s "$file" 2>/dev/null || echo 0)"
        mtime="$(stat -c %Y "$file" 2>/dev/null || echo 0)"
        lines+=("$rel_file|$size|$mtime")
      done < <(find "$path" -type f | sort)
    elif [[ -f "$path" ]]; then
      local size mtime
      size="$(stat -c %s "$path" 2>/dev/null || echo 0)"
      mtime="$(stat -c %Y "$path" 2>/dev/null || echo 0)"
      lines+=("$rel|$size|$mtime")
    fi
  done

  if [[ ${#lines[@]} -eq 0 ]]; then
    printf 'empty\n'
    return
  fi

  printf '%s\n' "${lines[@]}" | sort | sha256sum | awk '{print $1}'
}

transpile_templates() {
  if [[ ! -d "$app_root/templates" ]]; then
    rm -rf "$gen_root"
    mkdir -p "$gen_root"
    return
  fi

  mapfile -t template_files < <(find "$app_root/templates" -type f -name '*.html.eoc' | sort)
  rm -rf "$gen_root"
  mkdir -p "$gen_root"

  if [[ ${#template_files[@]} -eq 0 ]]; then
    return
  fi

  "$framework_root/build/eocc" \
    --template-root "$app_root/templates" \
    --output-dir "$gen_root" \
    "${template_files[@]}"
}

record_build_failure() {
  local stage="$1"
  local command="$2"
  local exit_code="$3"
  local output_file="$4"

  command="${command//$'\n'/ }"
  cp "$output_file" "$error_output_file"
  {
    printf 'stage=%s\n' "$stage"
    printf 'command=%s\n' "$command"
    printf 'exit_code=%s\n' "$exit_code"
    printf 'timestamp_utc=%s\n' "$(date -u +%Y-%m-%dT%H:%M:%SZ)"
  } >"$error_meta_file"
}

clear_build_failure_state() {
  rm -f "$error_output_file" "$error_meta_file"
}

compile_app() {
  local tmp_output
  tmp_output="$(mktemp)"

  if make -C "$framework_root" eocc >"$tmp_output" 2>&1; then
    :
  else
    local status=$?
    record_build_failure "tooling" "make -C $framework_root eocc" "$status" "$tmp_output"
    rm -f "$tmp_output"
    return "$status"
  fi

  if transpile_templates >"$tmp_output" 2>&1; then
    :
  else
    local status=$?
    record_build_failure "template_transpile" "$framework_root/build/eocc --template-root $app_root/templates --output-dir $gen_root ..." "$status" "$tmp_output"
    rm -f "$tmp_output"
    return "$status"
  fi

  mapfile -t framework_sources < <(find "$framework_root/src" -type f -name '*.m' | sort)
  mapfile -t app_sources < <(find "$app_root/src" -type f -name '*.m' 2>/dev/null | sort)
  mapfile -t generated_sources < <(find "$gen_root" -type f -name '*.m' 2>/dev/null | sort)

  if [[ -f "$app_root/app_lite.m" ]]; then
    app_sources+=("$app_root/app_lite.m")
  fi

  if [[ ${#app_sources[@]} -eq 0 ]]; then
    {
      echo "boomhauer: no app source files found under $app_root"
      echo "boomhauer: expected src/main.m (full mode) or app_lite.m (lite mode)"
    } >"$tmp_output"
    record_build_failure "app_discovery" "discover app sources" 1 "$tmp_output"
    rm -f "$tmp_output"
    return 1
  fi

  mkdir -p "$build_root"

  if {
    set +u
    # shellcheck disable=SC1090
    source "$gnustep_sh"
    set -u
    clang $(gnustep-config --objc-flags) \
      -I"$framework_root/src/Arlen" \
      -I"$framework_root/src/Arlen/Core" \
      -I"$framework_root/src/Arlen/Data" \
      -I"$framework_root/src/Arlen/HTTP" \
      -I"$framework_root/src/Arlen/MVC/Controller" \
      -I"$framework_root/src/Arlen/MVC/Middleware" \
      -I"$framework_root/src/Arlen/MVC/Routing" \
      -I"$framework_root/src/Arlen/MVC/Template" \
      -I"$framework_root/src/Arlen/MVC/View" \
      -I"$framework_root/src/Arlen/Support" \
      -I"$app_root/src" \
      "${app_sources[@]}" \
      "${framework_sources[@]}" \
      "${generated_sources[@]}" \
      -o "$app_binary" \
      $(gnustep-config --base-libs) \
      -ldl \
      -lcrypto
  } >"$tmp_output" 2>&1; then
    :
  else
    local status=$?
    record_build_failure "compile" "clang (app/framework/generated sources) -o $app_binary" "$status" "$tmp_output"
    rm -f "$tmp_output"
    return "$status"
  fi

  rm -f "$tmp_output"
  clear_build_failure_state
  return 0
}

child_pid=""
child_mode=""
stop_requested=0

stop_child() {
  if [[ -n "$child_pid" ]] && kill -0 "$child_pid" 2>/dev/null; then
    kill -TERM "$child_pid" 2>/dev/null || true
    wait "$child_pid" 2>/dev/null || true
  fi
  child_pid=""
  child_mode=""
}

on_signal() {
  stop_requested=1
  stop_child
}

trap on_signal INT TERM

start_app_child() {
  export ARLEN_APP_ROOT="$app_root"
  "$app_binary" "${server_args[@]}" &
  child_pid="$!"
  child_mode="app"
}

start_error_child() {
  export ARLEN_APP_ROOT="$app_root"
  export ARLEN_BOOMHAUER_BUILD_ERROR_FILE="$error_output_file"
  export ARLEN_BOOMHAUER_BUILD_ERROR_META_FILE="$error_meta_file"
  "$framework_root/build/boomhauer" "${server_args[@]}" &
  child_pid="$!"
  child_mode="build_error"
}

run_once() {
  if ! compile_app; then
    cat "$error_output_file" >&2 || true
    exit 1
  fi
  if [[ $prepare_only -eq 1 ]]; then
    exit 0
  fi
  export ARLEN_APP_ROOT="$app_root"
  exec "$app_binary" "${server_args[@]}"
}

if [[ $watch_mode -eq 0 ]]; then
  run_once
fi

if ! make -C "$framework_root" boomhauer >/dev/null; then
  echo "boomhauer: failed to build fallback dev error server" >&2
  exit 1
fi

last_fingerprint="$(watch_fingerprint)"

echo "boomhauer: watching $app_root"

while [[ $stop_requested -eq 0 ]]; do
  desired_mode="app"
  if ! compile_app; then
    desired_mode="build_error"
  fi

  if [[ "$desired_mode" == "app" ]]; then
    if [[ "$child_mode" != "app" ]] || [[ -z "$child_pid" ]] || ! kill -0 "$child_pid" 2>/dev/null; then
      stop_child
      start_app_child
    fi
  else
    if [[ "$child_mode" != "build_error" ]] || [[ -z "$child_pid" ]] || ! kill -0 "$child_pid" 2>/dev/null; then
      stop_child
      echo "boomhauer: build failed, serving diagnostic error page" >&2
      start_error_child
    fi
  fi

  restart_for_change=0
  while [[ $stop_requested -eq 0 ]] && [[ -n "$child_pid" ]] && kill -0 "$child_pid" 2>/dev/null; do
    sleep 1
    current_fingerprint="$(watch_fingerprint)"
    if [[ "$current_fingerprint" != "$last_fingerprint" ]]; then
      last_fingerprint="$current_fingerprint"
      echo "boomhauer: change detected, rebuilding..."
      restart_for_change=1
      stop_child
      break
    fi
  done

  if [[ $stop_requested -eq 1 ]]; then
    break
  fi

  if [[ -n "$child_pid" ]]; then
    set +e
    wait "$child_pid"
    child_status=$?
    set -e
    child_pid=""
    previous_mode="$child_mode"
    child_mode=""
    if [[ $restart_for_change -eq 0 && $child_status -ne 0 ]]; then
      echo "boomhauer: server exited with status $child_status" >&2
      if [[ "$previous_mode" == "build_error" && -f "$error_output_file" ]]; then
        cat "$error_output_file" >&2 || true
      fi
      exit "$child_status"
    fi
  fi

done

exit 0
