{
  "version": "phase5a-v1",
  "contracts": [
    {
      "id": "expression_identifier_binding_safety",
      "claim": "Expression identifier tokens require safe bindings and deterministic diagnostics for malformed shapes.",
      "source_docs": [
        "docs/PHASE4_ROADMAP.md",
        "docs/ARLEN_DATA.md",
        "docs/SQL_BUILDER_PHASE4_MIGRATION.md"
      ],
      "verification": [
        {
          "kind": "unit",
          "file": "tests/unit/Phase4ATests.m",
          "test": "testExpressionTemplateRequiresIdentifierBindingsForTokens"
        },
        {
          "kind": "unit",
          "file": "tests/unit/Phase4ATests.m",
          "test": "testExpressionTemplateRejectsUnsafeIdentifierBindings"
        },
        {
          "kind": "integration",
          "file": "tests/unit/PgTests.m",
          "test": "testSQLBuilderExpressionTemplatesWithIdentifierBindingsExecuteAgainstPostgres"
        }
      ],
      "unsupported_diagnostics": {
        "domain_symbol": "ALNSQLBuilderErrorDomain",
        "code_symbols": [
          "ALNSQLBuilderErrorInvalidArgument",
          "ALNSQLBuilderErrorInvalidIdentifier"
        ]
      }
    },
    {
      "id": "placeholder_contract_contiguity",
      "claim": "Builder output placeholder numbering remains contiguous and parameter ordering remains deterministic under composition stress.",
      "source_docs": [
        "docs/SQL_BUILDER_CONFORMANCE_MATRIX.md",
        "docs/PHASE4_ROADMAP.md"
      ],
      "verification": [
        {
          "kind": "conformance",
          "file": "tests/unit/Phase4ETests.m",
          "test": "testConformanceMatrixMatchesExpectedSnapshots"
        },
        {
          "kind": "long_run",
          "file": "tests/unit/Phase4ETests.m",
          "test": "testPropertyPlaceholderShiftingAcrossExpressionComposition"
        },
        {
          "kind": "long_run",
          "file": "tests/unit/Phase4ETests.m",
          "test": "testLongRunRegressionSuiteForNestedExpressionShapes"
        }
      ]
    },
    {
      "id": "locking_skip_locked_contract",
      "claim": "FOR UPDATE and SKIP LOCKED rendering is deterministic and invalid lock combinations fail explicitly.",
      "source_docs": [
        "docs/SQL_BUILDER_CONFORMANCE_MATRIX.md",
        "docs/PHASE4_ROADMAP.md"
      ],
      "verification": [
        {
          "kind": "unit",
          "file": "tests/unit/Phase4BTests.m",
          "test": "testForUpdateSkipLockedSnapshot"
        },
        {
          "kind": "unit",
          "file": "tests/unit/Phase4BTests.m",
          "test": "testSkipLockedRequiresForUpdate"
        },
        {
          "kind": "integration",
          "file": "tests/unit/PgTests.m",
          "test": "testSQLBuilderPhase4BFeaturesExecuteAgainstPostgres"
        }
      ],
      "unsupported_diagnostics": {
        "domain_symbol": "ALNSQLBuilderErrorDomain",
        "code_symbols": [
          "ALNSQLBuilderErrorInvalidArgument"
        ]
      }
    },
    {
      "id": "postgres_upsert_expression_contract",
      "claim": "PostgreSQL ON CONFLICT expression assignments and DO UPDATE WHERE semantics remain stable in SQL and execution behavior.",
      "source_docs": [
        "docs/SQL_BUILDER_CONFORMANCE_MATRIX.md",
        "docs/ARLEN_DATA.md"
      ],
      "verification": [
        {
          "kind": "conformance",
          "file": "tests/unit/Phase4ETests.m",
          "test": "testConformanceMatrixMatchesExpectedSnapshots"
        },
        {
          "kind": "integration",
          "file": "tests/unit/PgTests.m",
          "test": "testPostgresSQLBuilderAdvancedUpsertAssignmentsAndWhereExecute"
        },
        {
          "kind": "integration",
          "file": "tests/unit/PgTests.m",
          "test": "testPhase4EConformanceScenariosExecuteAgainstPostgres"
        }
      ]
    },
    {
      "id": "builder_diagnostics_redaction_and_cache_contract",
      "claim": "Builder execution diagnostics emit stable stage metadata while keeping SQL redacted by default and surfacing cache behavior explicitly.",
      "source_docs": [
        "docs/ARLEN_DATA.md",
        "docs/PHASE4_ROADMAP.md"
      ],
      "verification": [
        {
          "kind": "integration",
          "file": "tests/unit/PgTests.m",
          "test": "testBuilderExecutionEmitsStructuredEventsAndUsesCaches"
        },
        {
          "kind": "integration",
          "file": "tests/unit/PgTests.m",
          "test": "testBuilderExecutionErrorEventsIncludeSQLStateAndStayRedactedByDefault"
        }
      ]
    },
    {
      "id": "adapter_capability_metadata_contract",
      "claim": "Adapters publish deterministic capability metadata used for dialect expectation mapping and CI contract validation.",
      "source_docs": [
        "docs/PHASE5_ROADMAP.md",
        "docs/PHASE5A_RELIABILITY_CONTRACTS.md"
      ],
      "verification": [
        {
          "kind": "unit",
          "file": "tests/unit/Phase5ATests.m",
          "test": "testAdapterCapabilityMetadataMatchesFixtureContracts"
        }
      ]
    },
    {
      "id": "runtime_read_write_route_selection_contract",
      "claim": "Runtime routing deterministically selects read or write targets by operation class while preserving observable route metadata.",
      "source_docs": [
        "docs/PHASE5_ROADMAP.md",
        "docs/PHASE5B_RUNTIME_ROUTING.md",
        "docs/ARLEN_DATA.md"
      ],
      "verification": [
        {
          "kind": "unit",
          "file": "tests/unit/Phase5BTests.m",
          "test": "testRoutingSelectsReadAndWriteTargetsDeterministically"
        },
        {
          "kind": "integration",
          "file": "tests/integration/PostgresIntegrationTests.m",
          "test": "testDatabaseRouterReadWriteRoutingAcrossLiveAdapters"
        }
      ]
    },
    {
      "id": "read_after_write_stickiness_scope_contract",
      "claim": "Read-after-write stickiness applies only within configured bounded scope and transaction boundaries update stickiness only on successful commit.",
      "source_docs": [
        "docs/PHASE5_ROADMAP.md",
        "docs/PHASE5B_RUNTIME_ROUTING.md"
      ],
      "verification": [
        {
          "kind": "unit",
          "file": "tests/unit/Phase5BTests.m",
          "test": "testReadAfterWriteStickinessRespectsBoundedScope"
        },
        {
          "kind": "unit",
          "file": "tests/unit/Phase5BTests.m",
          "test": "testTransactionFailureDoesNotActivateStickinessButSuccessDoes"
        },
        {
          "kind": "integration",
          "file": "tests/integration/PostgresIntegrationTests.m",
          "test": "testDatabaseRouterReadWriteRoutingAcrossLiveAdapters"
        }
      ]
    },
    {
      "id": "routing_hook_and_fallback_contract",
      "claim": "Tenant/shard routing hooks and read-fallback behavior produce deterministic target selection and explicit unknown-target diagnostics.",
      "source_docs": [
        "docs/PHASE5_ROADMAP.md",
        "docs/PHASE5B_RUNTIME_ROUTING.md"
      ],
      "verification": [
        {
          "kind": "unit",
          "file": "tests/unit/Phase5BTests.m",
          "test": "testRouteTargetResolverSupportsTenantAndShardHints"
        },
        {
          "kind": "unit",
          "file": "tests/unit/Phase5BTests.m",
          "test": "testReadFallbackToWriteTargetOnReadFailure"
        },
        {
          "kind": "unit",
          "file": "tests/unit/Phase5BTests.m",
          "test": "testUnknownResolverTargetFailsDeterministically"
        }
      ],
      "unsupported_diagnostics": {
        "domain_symbol": "ALNDatabaseRouterErrorDomain",
        "code_symbols": [
          "ALNDatabaseRouterErrorUnknownTarget",
          "ALNDatabaseRouterErrorMissingAdapter"
        ]
      }
    },
    {
      "id": "multi_database_migration_targeting_contract",
      "claim": "CLI migration targeting applies deterministic ordering and idempotent state isolation per named database target.",
      "source_docs": [
        "docs/PHASE5_ROADMAP.md",
        "docs/PHASE5C_MULTI_DATABASE_TOOLING.md",
        "docs/CLI_REFERENCE.md"
      ],
      "verification": [
        {
          "kind": "integration",
          "file": "tests/integration/PostgresIntegrationTests.m",
          "test": "testArlenMigrateCommandSupportsNamedDatabaseTargetsAndFailureRetry"
        }
      ]
    },
    {
      "id": "migration_failure_retry_recovery_contract",
      "claim": "Target-scoped migration failure is explicit and retry after fixing migration content resumes from remaining pending files only.",
      "source_docs": [
        "docs/PHASE5_ROADMAP.md",
        "docs/PHASE5C_MULTI_DATABASE_TOOLING.md"
      ],
      "verification": [
        {
          "kind": "integration",
          "file": "tests/integration/PostgresIntegrationTests.m",
          "test": "testArlenMigrateCommandSupportsNamedDatabaseTargetsAndFailureRetry"
        }
      ]
    },
    {
      "id": "schema_codegen_target_manifest_contract",
      "claim": "Schema codegen emits deterministic per-target artifacts and includes explicit database target metadata in manifests.",
      "source_docs": [
        "docs/PHASE5_ROADMAP.md",
        "docs/PHASE5C_MULTI_DATABASE_TOOLING.md",
        "docs/ARLEN_DATA.md"
      ],
      "verification": [
        {
          "kind": "integration",
          "file": "tests/integration/PostgresIntegrationTests.m",
          "test": "testArlenSchemaCodegenSupportsNamedDatabaseTargets"
        },
        {
          "kind": "unit",
          "file": "tests/unit/SchemaCodegenTests.m",
          "test": "testRenderArtifactsIncludesDatabaseTargetMetadata"
        },
        {
          "kind": "unit",
          "file": "tests/unit/SchemaCodegenTests.m",
          "test": "testRenderArtifactsRejectsInvalidDatabaseTarget"
        }
      ]
    }
  ]
}
